<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">

        <title>Fugindo para as Colinas com Python</title>

        <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
        <meta name="author" content="Hakim El Hattab">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="reveal.js/css/reveal.css">
        <link rel="stylesheet" href="theme/azion.css" id="theme">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->

        <style type="text/css" media="screen">
            .happy {
                color: yellow;
            }

            .reveal section img {
                border: none;
            }

            .reveal ul.empty {
                list-style: none outside;
            }

			li {
				display: block;
			}

			.cursor {
				background-color: #666;
				color: white;
			}
			
			img {
				max-height: 90%;
			}
        </style>
    </head>

    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <section data-background="_images/python.jpg">
                        <h1 class="semi-opaque">Fugindo para as Colinas Com Python</h1>
                    </section>
                </section>

                <section>
                    <section>
                        <img src="_images/avatar-20170726.png" alt="Me" style="float:left;width:200px;" class="no-border">

                        <div>
                            <ul class="empty">
                                <li>Júlio Biason</li>
								<li>Azion Technologies<img src="_images/azion-logo.png" alt="Azion logo" class='company-logo'></li>
                                <li>@juliobiason</li>
                                <li>julio.biason@gmail.com</li>
                                <li><a href="http://presentations.juliobiason.net">http://presentations.juliobiason.net</a></li>
                            </ul>
                        </div>
                    </section>

                    <section>
                        <img src="_images/start-a-fight.jpg" alt="Eu faço perguntas em reuniões que eu não sei nada e reunião explode; não é de propósito" class='stretch'/>

						<aside class="notes">
							Eu sou famoso (ou era) por entrar eu reuniões, fazer uma
							pergunta e a reunião explodir em discussões (úteis, diga-se
							de passagem). Mas eu não fazia isso de propósito.
						</aside>
                    </section>

					<section>
						<img src="_images/fast-speaker.jpg" alt="Eu falo rárpido">

						<aside class="notes">
							Eu também tenho costume de falar rápido.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>O Problema</h2>

						<ul>
							<li class="fragment">"Hello world" não é muito didático</li>
							<li class="fragment">Escrever "Fujam para as colinas"</li>
							<li class="fragment">... com randomização de alguns elementos.</li>
							<li class="fragment">Ex: "Cujam para as folinas", "Lujam para as cofinas" e "Nujam para as folicas"</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>Solução</h2>

						<pre><code>"""Randomize a "Run to the hills" phrase."""

from __future__ import print_function

import random
from argparse import ArgumentParser


CONSONANTS = ['f', 'j', 'c', 'l', 'n']
PASSPHRASE = '{}u{}am para as {}o{}i{}as'


def print_phrase(consonants):
    """Print the phrase with the randomized consonants."""
    print(PASSPHRASE.format(*consonants).capitalize())


def totally_random():
    """Run a totally random way."""
    random.shuffle(CONSONANTS)
    print_phrase(CONSONANTS)


def switch_two():
    """Run by changing two steps at a time."""
    first = random.randint(0, 1)
    second = random.randint(2, 4)

    CONSONANTS[second], CONSONANTS[first] = \
        CONSONANTS[first], CONSONANTS[second]
    print_phrase(CONSONANTS)


if __name__ == "__main__":
    args = ArgumentParser()
    args.add_argument('-t', '--totally',
                      dest='totally',
                      default=False,
                      action='store_true',
                      help='Like, toootaly random')
    args.add_argument('-s', '--short',
                      dest='short',
                      default=False,
                      action='store_true',
                      help='Not so random')
    result = args.parse_args()

    if result.totally:
        totally_random()
    elif result.short:
        switch_two()
    else:
        print('Dude, option!')</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Docstrings</h2>

						<pre><code>
"""Randomize a "Run to the hills" phrase."""	
						</code></pre>

						<aside class="notes">
							Docstrings são utilizadas para documentar coisas
							em Python: módulos, funções, classes.

							Essas docstrings depois são utilizadas para o `help`
							e para extração de documentação, com aplicativos tipo
							o Sphinx.

							Outra coisa: Strings. Docstrings são strings normais,
							só que ficam logo abaixo do módulo/classe/função. E
							como strings normais, elas podem ser geradas com
							aspas simples ou duplas; as três aspas significam que
							a string pode ter quebra de linhas.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Módulos e imports</h2>

						<pre><code>
import random
from argparse import ArgumentParser
						</code></pre>

						<aside class="notes">
							Para importar módulos no Python, se usa `import` ou
							`from X import Y`.
						</aside>
					</section>

					<section>
						<h2>Módulos e imports</h2>

						<img src="_images/modules.png" alt="Visão de módulos"/>

						<aside class="notes">
							Imagine dois módulos: `mod1` e `mod2`.

							`mod1` tem uma função `func1` e `mod2` tem uma
							funcão `func2`.

							Como ambos estão em espaços separados, de `mod1` eu
							não consigo chamar `func2` (e nem o contrário).
						</aside>
					</section>

					<section>
						<h2>Módulos e imports</h2>

						<img src="_images/modules-import.png" alt="import"/>

						<aside class="notes">
							Se eu fizer `import mod2`, tudo que tiver dentro
							de `mod2` vai vir para o "namespace" atual (assim
							como quando tu cria um objeto a partir de uma classe
							ele vira uma "instância", ao importar um módulo,
							ele vira um namespace).

							Agora, usando o nome do módulo/namespace, eu consigo
							chamar `func2`, por exemplo.

							Como fazer a chamada usando o namespace é visto a seguir.
						</aside>
					</section>

					<section>
						<h2>Módulos e imports</h2>

						<img src="_images/modules-from-import.png" alt="from X import Y"/>

						<aside class="notes">
							Se eu fizer `from mod2 import func2`, a única coisa
							que eu vou trazer para o namespace atual é `func2`; 
							se houvessem outras funções ou outros módulos ou classes,
							essas não estariam disponíveis para uso.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Variáveis e tipos</h2>

						<pre><code>
CONSONANTS = ['f', 'j', 'c', 'l', 'n']
PASSPHRASE = '{}u{}am para as {}o{}i{}as'
						</code></pre>

						<aside class="notes">
							Primeiro, como vimos, strings são marcadas com aspas simples
							ou duplas. 

							Segundo, temos uma lista: `[]` indicam listas e, nesse caso,
							nos temos uma lista de strings (não existe o conceito de "um
							caractere" como em C, por exemplo -- simplesmente, strings
							com um caractere só).

							Terceiro: Existe uma string com uns colchetes no meio. Por
							si só, esses colchetes não fazem nada e se alguém tentar
							imprimir essa string, os colchetes ainda vão estar lá.

							Quarto: como pode ser visto, o nome dessas variávels está
							em maiúsculo. Isso é apenas por notação para indicar 
							constantes, embora o Python não tenha esse conceito de
							constantes; isso é apenas convenção (e, mais pra frente,
							nós vamos estragar essa convenção.)
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Funções</h2>

						<pre><code>
def print_phrase(consonants):
    """Print the phrase with the randomized consonants."""
						</code></pre>

						<aside class="notes">
							Nossa primeira função, sem nada de especial:

							Primeiro, elas começam com `def`.

							Segundo, elas tem nomes e, por padrão, tem que ser em
							minúsculas e separadas por underscore; não existe
							nada na linguagem barrando criar funções com nomes
							todos em maiúsculas ou com camelCase, mas, de novo, 
							é a convenção da comunidade.

							Terceiro, funções tem parâmetros, que seguem a mesma
							convenção de nomes que já vimos.

							Quarto, funcões são seguidas de dois pontos.

							Quinto: Python não usa colchetes para blocos; blocos
							são definidos por identação (como pode ser visto pela
							docstring).
						</aside>
					</section>

					<section>
						<h2>Funções</h2>

						<pre><code>
def print_phrase(consonants, something_else):
						</code></pre>

						<aside class="notes">
							Para ter mais parâmetros, basta adicionar os parâmetros
							separados por vírgulas.
						</aside>
					</section>

					<section>
						<h2>Funcões</h2>

						<pre><code>
def soma(primeiro, segundo):
    total = primeiro + segundo
	return total
						</code></pre>

						<aside class="notes">
							Se uma função tem algum retorno, basta adicionar `return`;
							funções sem `return` retornam um valor vazio, chamado `None`
							(que é o mesmo que `nil`, `null` e tantos outros nomes).

							Não existe diferença na hora de criar uma "função" e uma
							"procedure", como existe no Pascal: Simplesmente funções que
							não retornam valor não retornam valor (e ficam como None).
						</aside>
					</section>

					<section>
						<h2>Funções</h2>

						<pre><code>
soma(1, 2)
						</code></pre>

						<aside class="notes">
							Para chamar uma função, basta chamar a função passando os
							parâmetros.
						</aside>
					</section>

					<section>
						<h2>Funções</h2>

						<pre><code>
soma(primeiro=2, segundo=3)
						</code></pre>

						<aside class="notes">
							O legal de Python é que é possível colocar nome dos
							parâmetros na chamada da função...
						</aside>
					</section>

					<section>
						<h2>Funções</h2>

						<pre><code>
soma(segundo=3, primeiro=2)
						</code></pre>

						<aside class="notes">
							... e por isso dá pra misturar a ordem dos parâmetros,
							se ficar mais fácil de ler.

							Também ajuda se a função tiver vários parâmetros, sem
							contar que ajuda quem tiver lendo o código pra não
							precisar voltar e ver quais são os parâmetros.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Welcome to Hell</h2>

						<pre><code>
    print(PASSPHRASE.format(*consonants).capitalize())
						</code></pre>
					</section>
				</section>
            </div>
        </div>

        <script src="reveal.js/lib/js/head.min.js"></script>
        <script src="reveal.js/js/reveal.js"></script>

        <script>
            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,
                // showNotes: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
                    { src: 'reveal.js/plugin/notes/notes.js', async: true }
                ]
            });
        </script>

    </body>
</html>
