<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">

        <title>Fugindo para as Colinas com Python</title>

        <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
        <meta name="author" content="Hakim El Hattab">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="reveal.js/css/reveal.css">
        <link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->

        <style type="text/css" media="screen">
            .happy {
                color: yellow;
            }

            .reveal section img {
                border: none;
            }

            .reveal ul.empty {
                list-style: none outside;
            }

            li {
                display: block;
            }

            .cursor {
                background-color: #666;
                color: white;
            }
            
            img {
                max-height: 90%;
            }

            .semi-opaque {
                background-color: rgba(0, 0, 0, 0.8);
                color: #fff;
                text-shadow: 2px 2px #000;
            }

            .reveal h1 {
                font-size: 3em !important;
            }
        </style>
    </head>

    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <section data-background="_images/python.jpg" data-header>
                        <h1 class="semi-opaque">Fugindo para as Colinas Com Python</h1>
                    </section>
                </section>

                <section>
                    <section>
                        <img src="_images/avatar-20170726.png" alt="Me" style="float:left;width:200px;" class="no-border">

                        <div>
                            <ul class="empty">
                                <li>Júlio Biason</li>
								<li><a href="https://functional.cafe/@juliobiason">https://functional.cafe/@juliobiason</a></li>
								<li><a href="https://t.me/juliobiason">https://t.me/juliobiason</a></li>
                                <li>julio.biason@pm.me</li>
                                <li><a href="https://presentations.juliobiason.me">https://presentations.juliobiason.me</a></li>
                            </ul>
                        </div>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>O Problema</h2>

                        <ul>
                            <li class="fragment">"Hello world" não é muito didático</li>
                            <li class="fragment">Escrever "Fujam para as colinas"</li>
                            <li class="fragment">... com randomização de alguns elementos.</li>
                            <li class="fragment">Ex: "Cujam para as folinas", "Lujam para as cofinas" e "Nujam para as folicas"</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Solução</h2>

                        <pre><code class="hljs python" data-trim>"""Randomize a "Run to the hills" phrase."""

from __future__ import print_function

import random
from argparse import ArgumentParser


CONSONANTS = ['f', 'j', 'c', 'l', 'n']
PASSPHRASE = '{}u{}am para as {}o{}i{}as'


def print_phrase(consonants):
    """Print the phrase with the randomized consonants."""
    print(PASSPHRASE.format(*consonants).capitalize())


def totally_random():
    """Run a totally random way."""
    random.shuffle(CONSONANTS)
    print_phrase(CONSONANTS)


def switch_two():
    """Run by changing two steps at a time."""
    first = random.randint(0, 1)
    second = random.randint(2, 4)

    CONSONANTS[second], CONSONANTS[first] = \
        CONSONANTS[first], CONSONANTS[second]
    print_phrase(CONSONANTS)


def unknown():
    """We don't know what to do."""
    print('Dude, option!')


if __name__ == "__main__":
    args = ArgumentParser()
    args.add_argument('-t', '--totally',
                      dest='type',
                      action='store_const',
                      const='totally',
                      help='Like, toootaly random')
    args.add_argument('-s', '--short',
                      dest='type',
                      action='store_const',
                      const='switch'
                      help='Not so random')
    result = args.parse_args()

    callbacks = {
        'totally': totally_random,
        'switch': switch_two
    }

    func = callbacks.get(result.type, unknown)
    func()</code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Docstrings</h2>

                        <pre><code class="hljs python" data-trim>
"""Randomize a "Run to the hills" phrase."""    
                        </code></pre>

                        <aside class="notes">
                            Docstrings são utilizadas para documentar coisas
                            em Python: módulos, funções, classes.

                            Essas docstrings depois são utilizadas para o `help`
                            e para extração de documentação, com aplicativos tipo
                            o Sphinx.

                            Outra coisa: Strings. Docstrings são strings normais,
                            só que ficam logo abaixo do módulo/classe/função. E
                            como strings normais, elas podem ser geradas com
                            aspas simples ou duplas; as três aspas significam que
                            a string pode ter quebra de linhas.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Módulos e imports</h2>

                        <pre><code class="hljs python" data-trim>
import random
from argparse import ArgumentParser
                        </code></pre>

                        <aside class="notes">
                            Para importar módulos no Python, se usa `import` ou
                            `from X import Y`.
                        </aside>
                    </section>

                    <section>
                        <h2>Módulos e imports</h2>

                        <img src="_images/modules.png" alt="Visão de módulos"/>

                        <aside class="notes">
                            Imagine dois módulos: `mod1` e `mod2`.

                            `mod1` tem uma função `func1` e `mod2` tem uma
                            funcão `func2`.

                            Como ambos estão em espaços separados, de `mod1` eu
                            não consigo chamar `func2` (e nem o contrário).
                        </aside>
                    </section>

                    <section>
                        <h2>Módulos e imports</h2>

                        <img src="_images/modules-import.png" alt="import"/>

                        <aside class="notes">
                            Se eu fizer `import mod2`, tudo que tiver dentro
                            de `mod2` vai vir para o "namespace" atual (assim
                            como quando tu cria um objeto a partir de uma classe
                            ele vira uma "instância", ao importar um módulo,
                            ele vira um namespace).

                            Agora, usando o nome do módulo/namespace, eu consigo
                            chamar `func2`, por exemplo.

                            Como fazer a chamada usando o namespace é visto a seguir.
                        </aside>
                    </section>

                    <section>
                        <h2>Módulos e imports</h2>

                        <img src="_images/modules-from-import.png" alt="from X import Y"/>

                        <aside class="notes">
                            Se eu fizer `from mod2 import func2`, a única coisa
                            que eu vou trazer para o namespace atual é `func2`; 
                            se houvessem outras funções ou outros módulos ou classes,
                            essas não estariam disponíveis para uso.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Variáveis e tipos</h2>

                        <pre><code class="hljs python" data-trim>
CONSONANTS = ['f', 'j', 'c', 'l', 'n']
PASSPHRASE = '{}u{}am para as {}o{}i{}as'
                        </code></pre>

                        <aside class="notes">
                            Primeiro, como vimos, strings são marcadas com aspas simples
                            ou duplas. 

                            Segundo, temos uma lista: `[]` indicam listas e, nesse caso,
                            nos temos uma lista de strings (não existe o conceito de "um
                            caractere" como em C, por exemplo -- simplesmente, strings
                            com um caractere só).

                            Terceiro: Existe uma string com uns colchetes no meio. Por
                            si só, esses colchetes não fazem nada e se alguém tentar
                            imprimir essa string, os colchetes ainda vão estar lá.

                            Quarto: como pode ser visto, o nome dessas variávels está
                            em maiúsculo. Isso é apenas por notação para indicar 
                            constantes, embora o Python não tenha esse conceito de
                            constantes; isso é apenas convenção (e, mais pra frente,
                            nós vamos estragar essa convenção.)
                        </aside>
                    </section>

                    <section>
                        <h2>Variáveis e tipos (um pouco mais)</h2>

                        <ul>
                            <li><code>" ou '</code>: Strings</li>
                            <li><code>[]</code>: Listas/arrays</li>
                            <li><code>{}</code>: Dicionários/mapas/objetos/arrays associativos</li>
                            <li><code>()</code>: Tuplas</li>
                            <li><code>Set()</code>: Conjuntos (tipo lista, sem duplicações)</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Funções</h2>

                        <pre><code class="hljs python" data-trim>
def print_phrase(consonants):
    """Print the phrase with the randomized consonants."""
                        </code></pre>

                        <aside class="notes">
                            Nossa primeira função, sem nada de especial:

                            Primeiro, elas começam com `def`.

                            Segundo, elas tem nomes e, por padrão, tem que ser em
                            minúsculas e separadas por underscore; não existe
                            nada na linguagem barrando criar funções com nomes
                            todos em maiúsculas ou com camelCase, mas, de novo, 
                            é a convenção da comunidade.

                            Terceiro, funções tem parâmetros, que seguem a mesma
                            convenção de nomes que já vimos.

                            Quarto, funcões são seguidas de dois pontos.

                            Quinto: Python não usa colchetes para blocos; blocos
                            são definidos por identação (como pode ser visto pela
                            docstring).
                        </aside>
                    </section>

                    <section>
                        <h2>Funções</h2>

                        <pre><code class="hljs python" data-trim>
def print_phrase(consonants, something_else):
                        </code></pre>

                        <aside class="notes">
                            Para ter mais parâmetros, basta adicionar os parâmetros
                            separados por vírgulas.
                        </aside>
                    </section>

                    <section>
                        <h2>Funcões</h2>

                        <pre><code class="hljs python" data-trim>
def soma(primeiro, segundo):
    total = primeiro + segundo
    return total
                        </code></pre>

                        <aside class="notes">
                            Se uma função tem algum retorno, basta adicionar `return`;
                            funções sem `return` retornam um valor vazio, chamado `None`
                            (que é o mesmo que `nil`, `null` e tantos outros nomes).

                            Não existe diferença na hora de criar uma "função" e uma
                            "procedure", como existe no Pascal: Simplesmente funções que
                            não retornam valor não retornam valor (e ficam como None).
                        </aside>
                    </section>

                    <section>
                        <h2>Funções</h2>

                        <pre><code class="hljs python" data-trim>
soma(1, 2)
                        </code></pre>

                        <aside class="notes">
                            Para chamar uma função, basta chamar a função passando os
                            parâmetros.
                        </aside>
                    </section>

                    <section>
                        <h2>Funções</h2>

                        <pre><code class="hljs python" data-trim>
soma(primeiro=2, segundo=3)
                        </code></pre>

                        <aside class="notes">
                            O legal de Python é que é possível colocar nome dos
                            parâmetros na chamada da função...
                        </aside>
                    </section>

                    <section>
                        <h2>Funções</h2>

                        <pre><code class="hljs python" data-trim>
soma(segundo=3, primeiro=2)
                        </code></pre>

                        <aside class="notes">
                            ... e por isso dá pra misturar a ordem dos parâmetros,
                            se ficar mais fácil de ler.

                            Também ajuda se a função tiver vários parâmetros, sem
                            contar que ajuda quem tiver lendo o código pra não
                            precisar voltar e ver quais são os parâmetros.
                        </aside>
                    </section>

                    <section>
                        <h2>Funções</h2>

                        <pre><code class="hljs python" data-trim>
def soma(primeiro=0, segundo=0):
                        </code></pre>

                        <pre><code class="hljs python" data-trim>
soma()
soma(1)
soma(segundo=3)
                        </code></pre>

                        <aside class="notes">
                            Parâmetros também podem ser opcionais, passando
                            o valor que o mesmo vai ter se não for passado.

                            E, com nomes nos parâmetros, é possível "pular"
                            por parâmetros que tem valor default.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Pausa: Varargs</h2>

                        <pre><code class="hljs python" data-trim>
def soma(primeiro, segundo):
    total = primeiro + segundo
    return total
                        </code></pre>

                        <pre class="fragment"><code class="hljs python" data-trim>
soma(1)
                        </code></pre>

                        <pre class="fragment"><code class="hljs python" data-trim>
soma(1, 2, 3)
                        </code></pre>

                        <aside class="notes">
                            O que acontece quando não se passa a quantidade correta
                            de parâmetros para uma função?
                        </aside>
                    </section>

                    <section>
                        <h2>Pausa: Varargs</h2>

                        <pre><code class="hljs python" data-trim>
TypeError: soma() takes exactly 2 arguments (3 given)
                        </code></pre>

                        <aside class="notes">
                            Simplesmente, o Python se recusa a executar porque não
                            foi passado o número correto de parâmetros.
                        </aside>
                    </section>

                    <section>
                        <h2>Pausa: Varargs</h2>

                        <pre><code class="hljs python" data-trim>
def soma(*valores):
                        </code></pre>

                        <aside class="notes">
                            Entram os varargs: Quando um parâmetro tem um asterísco
                            na frente do nome, ele significa "colete tudo que foi
                            passado que não conseguiu associar a um parâmetro e
                            retorne como lista"
                        </aside>
                    </section>

                    <section>
                        <h2>Pausa: Varargs</h2>

                        <pre><code class="hljs python" data-trim>
def soma(*valores):
    print(valores)
                        </code></pre>

                        <pre><code class="hljs python" data-trim>
soma(1, 2, 3, 4, 5)
                        </code></pre>

                        <pre class="fragment"><code class="hljs python" data-trim>
[1, 2, 3, 4, 5]
                        </code></pre>
                    </section>

                    <section>
                        <h2>Pausa: Varargs</h2>

                        <pre><code class="hljs python" data-trim>
def soma(inicial, segundo=0, *valores):
    print(inicial)
    print(segundo)
    print(valores)

                        </code></pre>

                        <pre><code class="hljs python" data-trim>
soma(2)
                        </code></pre>

                        <pre><code class="hljs python" data-trim>
2
0
[]
                        </code></pre>
                    </section>

                    <section>
                        <h2>Pausa: Varargs</h2>

                        <p>
                            E o que acontece com parâmetros com nomes?
                        </p>
                    </section>

                    <section>
                        <h2>Pausa: Varargs</h2>

                        <pre><code class="hljs python" data-trim>
def soma(**valores):
    print(valores)
                        </code></pre>

                        <pre><code class="hljs python" data-trim>
soma(primeiro=1, segundo=2)
                        </code></pre>

                        <pre><code class="hljs python" data-trim>
{'primeiro': 1, 'segundo': 2}
                        </code></pre>

                        <aside class="notes">
                            Para capturar parâmetros com nomes, usam-se
                            dois asteríscos na frente do nome. Assim como um
                            asterísco significa "capture tudo que não for
                            capturado por parâmetros normais", dois asteríscos
                            significam "capture tudo que tiver nome e não
                            for capturado por parâmetros normais".

                            E agora também vimos como funcionam dicionários
                            em Python (que são chamadas de "objetos", "arrays
                            associativos", "mapas" e outros nomes em outras
                            linguagens).
                        </aside>
                    </section>

                    <section>
                        <h2>Pausa: Varargs</h2>

                        <p>
                            O legal de varargs (e o asterísco) é que ele
                            funciona pros dois lados: Não só ele transforma
                            parâmetros em lista, mas ele também pode
                            funcionar para converter uma lista em parâmetros.
                        </p>
                    </section>

                    <section>
                        <h2>Pausa: Varargs</h2>

                        <pre><code class="hljs python" data-trim>
params = [4, 4]
soma(*params)
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Pausa: Objetos</h2>

                        <p>
                            Sem entrar em detalhes sobre como
                            criar objetos:
                        </p>

                        <ul>
                            <li class="fragment">Objetos tem métodos (funções associadas a um objeto)</li>
                            <li class="fragment">Para chamar um método, usa-se '.' e o nome do método</li>
                            <li class="fragment">Strings são objetos</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Pausa: Objetos</h2>

                        <pre><code class="hljs python" data-trim>
"isso é uma string"
                        </code></pre>

                        <aside class="notes">
                            Uma string é um objeto.
                        </aside>
                    </section>

                    <section>
                        <h2>Pausa: Objetos</h2>

                        <pre><code class="hljs python" data-trim>
help("isso é uma string")
                        </code></pre>

                        <aside class="notes">
                            Pedindo help num objeto vai mostrar o help
                            da classe do objeto; no caso, serão mostrados
                            todos os métodos presentes no objeto "str", de
                            string.

                            E é por isso que é interessante colocar docstrings:
                            help() vai mostrar tudo que aquele objeto faz,
                            desde que documentado.
                        </aside>
                    </section>

                    <section>
                        <h2>Pausa: Objetos</h2>

                        <pre><code class="hljs python" data-trim>
"isso é uma string".capitalize()
                        </code></pre>

                        <pre><code class="hljs python" data-trim>
frase = "isso é uma string"
frase.capitalize()
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h2><span style="color:crimson">Welcome to Hell</span></h2>

                        <pre><code class="hljs python" data-trim>
    print(PASSPHRASE.format(*consonants).capitalize())
                        </code></pre>

                        <aside class="notes">
                            Holy cow!
                        </aside>
                    </section>

                    <section>
                        <h2><span style="color:crimson">Welcome to</span> Hell</h2>

                        <p>O que sabemos:</p>

                        <ul>
                            <li class="fragment"><code>PASSPHRASE</code> é uma string.</li>
                            <li class="fragment"><code>.format</code> deve ser um método de strings.</li>
                            <li class="fragment"><code>consonants</code> é uma lista</li>
                            <li class="fragment"><code>*consonants</code> tá transformando a lista em parâmetros</li>
                            <li class="fragment"><code>capitalize</code> também deve ser um método de strings</li>
                        </ul>
                    </section>

                    <section>
                        <h2><span style="color:crimson">Welcome</span> to Hell</h2>

                        <p>
                            Lembram que <code>PASSPHRASE</code> tinha
                            um monte de colchetes no meio?
                        </p>

                        <p class="fragment">
                            <code>.format()</code> converte cada um
                            deles para um dos parâmetros passados.
                        </p>
                    </section>

                    <section>
                        <h2><span style="color:crimson">Welcome</span> to Hell</h2>

                        <pre><code class="hljs python" data-trim>
'Bem vindo {}!'.format('Júlio')
                        </code></pre>

                        <pre><code class="hljs python" data-trim>
Bem vindo Júlio!
                        </code></pre>

                        <aside class="notes">
                            Format funciona da seguinte format: Tudo que tiver `{}` no
                            meio, ele troca pelo que vier de parâmetro.
                        </aside>
                    </section>

                    <section>
                        <h2>Welcome to Hell</h2>

                        <pre><code class="hljs python" data-trim>
PASSPHRASE = '{}u{}am para as {}o{}i{}as'
PASSPHRASE.format('f', 'j', 'c', 'l', 'n')
                        </code></pre>

                        <pre class="fragment"><code class="hljs python" data-trim>
'fujam para as colinas'
                        </code></pre>

                        <aside class="notes">
                            ... se eu passar cada uma das consoantes no format com
                            a nossa string original, ele vai trocar cada um dos `{}`
                            pelas consoantes passadas como parâmetros, uma a uma.
                        </aside>
                    </section>

                    <section>
                        <h2>Welcome to... Hell</h2>
                        
                        <pre><code class="hljs python" data-trim>
CONSONANTS = ['f', 'j', 'c', 'l', 'n']
PASSPHRASE = '{}u{}am para as {}o{}i{}as'
PASSPHRASE.format(*CONSONANTS)
                        </code></pre>

                        <pre><code class="hljs python" data-trim>
'fujam para as colinas'
                        </code></pre>

                        <aside class="notes">
                            ... e como a gente viu que dá pra converter listas
                            para parâmetros, usando o `*` a gente passa a lista,
                            que é convertida para chamada de parâmetros exatamente
                            como anteriormente e ainda temos o mesmo resultado.
                        </aside>
                    </section>

                    <section>
                        <h2>Welcome to... Hell?</h2>

                        <pre><code class="hljs python" data-trim>
'fujam para as colinas'.capitalize()
                        </code></pre>

                        <pre><code class="hljs python" data-trim>
Fujam para as colinas
                        </code></pre>

                        <aside class="notes">
                            E `capitalize()` simplesmente converte o primeiro
                            caractere para maiúscula.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Randomizações</h2>

                        <pre><code class="hljs python" data-trim>
def totally_random():
    """Run a totally random way."""
    random.shuffle(CONSONANTS)
    print_phrase(CONSONANTS)
                        </code></pre>

                        <aside class="notes">
                            Nada complicado: A gente chama o `random.shuffle`,
                            que é um método do módulo `random` que a gente fez
                            import lá no começo.

                            O único problema aqui é que `shuffle` faz *in-place*,
                            ou seja, a lista vai ter o conteúdo alterado.
                        </aside>
                    </section>

                    <section>
                        <h2>Randomizações</h2>

                        <pre><code class="hljs python" data-trim>
def switch_two():
    """Run by changing two steps at a time."""
    first = random.randint(0, 1)
    second = random.randint(2, 4)
                        </code></pre>

                        <aside class="notes">
                            Essa função simplesmente escolhe dois números randomicamente.

                            O primeiro vai de 0 a 1.

                            E o segundo de 2 a 4.

                            ... que, se a gente contar, são exatamente as posições das
                            consoantes de "fujam" e de "colinas", respecticamente,
                            começando por 0.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Welcome to hell, maybe?</h2>

                        <pre><code class="hljs python" data-trim>
    CONSONANTS[second], CONSONANTS[first] = \
        CONSONANTS[first], CONSONANTS[second]
                        </code></pre>
                    </section>

                    <section>
                        <h2>Welcome to Listas!</h2>

                        <pre><code class="hljs python" data-trim>
# CONSONANTS = ['f', 'j', 'c', 'l', 'n']
# second = random.randint(2, 4)
CONSONANTS[second]
                        </code></pre>

                        <aside class="notes">
                            Para acessar um elemento específico de uma lista
                            é só usar colchetes e um índice; ou seja, iremos
                            pegar a consoante indicada pelo número randômico
                            seleciado (entre 2 e 4, inclusive).
                        </aside>
                    </section>

                    <section>
                        <h2>Welcome to Tuples!</h2>

                        <p>
                            Tuplas são como listas, só que 
                            não podem ser alteradas.
                        </p>

                        <p>
                            E pra criar uma tupla:
                        </p>

                        <pre><code class="hljs python" data-trim>
valor, valor
                        </code></pre>

                        <p class="fragment">Ou mais bonitinho: <code>(valor, valor)</code></p>
                    </section>

                    <section>
                        <h2>Welcome to Destructuring</h2>

                        <pre><code class="hljs python" data-trim>
primeiro, segundo = [1, 2]
print(primeiro)
print(segundo)
                        </code></pre>

                        <pre><code class="hljs python" data-trim>
1
2
                        </code></pre>

                        <aside class="notes">
                            Destructuring (e não destroying) serve
                            para "desmontar" tuplas e listas.

                            Por exemplo, a lista tem dois elementos; se
                            eu apontar os dois valores para ela, o
                            primeiro vai ter o primeiro valor e o segundo,
                            o segundo; se forem três, eu preciso de três
                            variáveis.

                            E se o número de váriaveis estiver errado,
                            dá erro.
                        </aside>
                    </section>

                    <section>
                        <h2>Tudo junto, agora!</h2>

                        <pre><code class="hljs python" data-trim>
    CONSONANTS[second], CONSONANTS[first] = \
        CONSONANTS[first], CONSONANTS[second]
                        </code></pre>

                        <pre class="fragment"><code class="hljs python" data-trim>
tmp = CONSONANTS[first]
CONSONANTS[first] = CONSONANTS[second]
CONSONANTS[second] = tmp
                        </code></pre>

                        <aside class="notes">
                            Ou seja, estamos pegando a consonante
                            escolhida randomicamente entre 0 e 1 (f e j)
                            e a consoante escolhida randomicante entre
                            2 e 4 (c, l, n) e criando uma tupla com esses
                            dois valores; a seguir a gente desmonta
                            (destructura) esses dois na ordem inversa.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>O Pai de Todos Módulos</h2>

                        <pre><code class="hljs python" data-trim>
if __name__ == "__main__":
                        </code></pre>

                        <aside class="notes">
                            Falamos antes que um módulo, quando
                            importado, vira um namespace.

                            Pois bem, namespaces tem nomes que podem
                            ser acessados com `__name__`.

                            E o que acontece quando um script é 
                            executado diretamente pela linha de
                            comando? O módulo é "importado" pelo
                            interpretador, mas qual é o nome do
                            namespace?

                            `__main__`.

                            Essa construção permite que scripts sejam
                            tanto executados diretamente quando importados.

                            No caso, todo o conteúdo desse if só vai
                            ser executado se for executado pela linha
                            de comando. Se for importado por um outro
                            script, o script vai ter acesso às funções,
                            mas não vai ser afetado pela leitura da
                            linha de comando.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>A linha de comando</h2>

                        <pre><code class="hljs python" data-trim>
    args = ArgumentParser()
    args.add_argument('-t', '--totally',
                      dest='type',
                      action='store_const',
                      const='totally',
                      help='Like, toootaly random')
    args.add_argument('-s', '--short',
                      dest='type',
                      action='store_const',
                      const='switch'
                      help='Not so random')
    result = args.parse_args()
                        </code></pre>

                        <aside class="notes">
                            Nada de muito mágico aqui, exceto que o
                            ArgumentParser faz um monte de coisas pra
                            nós: nós só definimos os parametros, onde eles
                            vão ficar no final, qual ação a ser tomada
                            e um help. E o ArgumentParser faz todo
                            o resto.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Funções são cidadãos de primeira classe</h2>

                        <pre><code class="hljs python" data-trim>
    callbacks = {
        'totally': totally_random,
        'switch': switch_two
    }
    func = callbacks.get(result.type, unknown)
    func()
                        </code></pre>

                        <aside class="notes">
                            "Cidadão de primeira classe" significa que
                            funções são tratadas como qualquer outro
                            objeto/elemento/variável. No caso estamos
                            criado um dicionário onde a chave é uma
                            string (não por coincidência as mesmas
                            strings que estão no argumentparser) e
                            o valor são funções.

                            Dicionários são objetos como strings e 
                            possuem uma função `get()`; essa função
                            retorna o valor da entrada com a chave 
                            indicada e, caso não exista, retorna um valor
                            padrão (que normalmente é `None`).

                            Aqui temos, então, uma relação das possíveis
                            strings que existem no ArgumentParser e as
                            funções que podem ser chamadas; com o valor
                            vindo da linha de comando, selecionamos a
                            função `totally_random` ou `switch_two` ou,
                            ainda, se o valor de `type` não existir,
                            assume-se `unkonwn` -- de certa forma, agora
                            `func` é um ponteiro para uma função.

                            E para executar a função apontada pela variável,
                            basta colocar os parênteses, como faria com
                            qualquer função em Python.

                            E esse é basicamente o formato de como se faz
                            `switch` em Python.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>O que faltou?</h2>
                    </section>

                    <section>
                        <h3>List comprehensions</h3>

                        <pre><code class="hljs python" data-trim>
numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
pares = [num
         for num
         in numeros
         if num % 2 = 0]
                        </code></pre>

                        <p class="fragment">Curiosidade: Strings são iteráveis como listas.</p>
                    </section>

                    <section>
                        <h3>Generators</h3>

                        <pre><code class="hljs python" data-trim>
numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
pares = (num
         for num
         in numeros
         if num % 2 = 0)
                        </code></pre>

                        <pre><code class="hljs python fragment" data-trim>
&lt;generator object &lt;genexpr&gt; at 0x7f03ce4e67d0&gt;
                        </code></pre>
                    </section>

                    <section>
                        <h3>Laziness</h3>
                    </section>
                </section>

                <section>
                    <section data-background="_images/python.jpg">
                        <h1 class="semi-opaque">Fulindo para as Cojinas com Python</h1>
                    </section>

                    <section data-background="_images/python.jpg">
                        <h1 class="semi-opaque">Fucindo para as Lonijas com Python</h1>
                    </section>
                </section>

                <section data-background='_images/thats-all-folks.jpg'>
                    <section>
                        <div class="semi-opaque">
                            <ul class="empty">
								<li><a href="https://functional.cafe/@juliobiason">https://functional.cafe/@juliobiason</a></li>
								<li><a href="https://t.me/juliobiason">https://t.me/juliobiason</a></li>
                                <li>julio.biason@pm.me</li>
                                <li><a href="https://presentations.juliobiason.me">https://presentations.juliobiason.me</a></li>
                            </ul>
                        </div>

                        <h3></h3> <!-- this is stupid, but I'm not in the mood to figure out the proper CSS -->

                        <h1 class="fragment semi-opaque">Perguntas?</h1>
                    </section>
                </section>
            </div>
        </div>

        <script src="reveal.js/lib/js/head.min.js"></script>
        <script src="reveal.js/js/reveal.js"></script>

        <script>
            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,
                // showNotes: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
                    { src: 'reveal.js/plugin/notes/notes.js', async: true }
                ]
            });
        </script>

    </body>
</html>
