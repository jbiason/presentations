<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Python</title>

        <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
        <meta name="author" content="Hakim El Hattab">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="reveal.js/css/reveal.css">
        <link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'reveal.js/css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->

        <!-- personal styles -->
        <style>
.semi-opaque {
    background-color: rgba(0, 0, 0, 0.7);
}

* {
    hyphens: none !important;
    -moz-hyphens: none !important;
}
        </style>
    </head>

    <body>
        <div class="reveal">
            <div class="slides">
                <section data-background='_images/zen-of-python-poster-a3.png' class='semi-opaque'>
                    <h1>Python</h1>
                </section>

                <section>
                    <section>
                        <h2>O que é Python?</h2>
                    </section>

                    <section>
                        <ul>
                            <li>Linguagem interpretada.</li>
                            <li>Dinamicamente tipada.</li>
                            <li>Principais usos em pesquisas e web.
                                <ul>
                                    <li>Assim como o Linux "vazou" dos servidores para os
                                    Desktops, Python parece estar "vazando" do meio acadêmico/pesquisa
                                    para os servidores.</li>
                                </ul>
                            </li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>O Zen de Python</h2>

                        <p>Começou em uma brincadeira do Tim Peters (um dos desenvolvedores do Python),
                        mas acabou virando um PEP (PEP 20) e hoje faz parte da filosofia de desenvolvimento
                        do Python.</p>
                    </section>

                    <section>
                        <ul>
                            <li>Bonito é melhor que feio.</li>
                            <li>Explícito é melhor que implícito.</li>
                            <li>Simples é melhor que complexo.</li>
                            <li>Complexo é melhor que complicado.</li>
                            <li>Plano é melhor que aninhado.</li>
                            <li>Esparço é melhor que denso.</li>
                            <li>Legibilidade conta.</li>
                        </ul>
                    </section>

                    <section>
                        <ul>
                            <li>Casos especiais não são especiais o suficiente para quebrar as regras.
                            <ul><li>Embora praticabilidade ganhe de puridade.</li></ul>
                            </li>
                            <li>Erros nunca devem passam silenciosamente.
                            <ul><li>A não ser que sejam explicitamente silenciados.</li></ul>
                            </li>
                            <li>Em caso de ambiguidade, evite a tentação de adivinhar.</li>
                            <li>Deve haver um -- e preferencialmente apenas um -- modo óbvio de fazer algo.
                            <ul><li>Embora talvez não seja tão óbvio de primeira a não ser que você seja Holandês.</li></ul>
                            </li>
                        </ul>
                    </section>

                    <section>
                        <ul>
                            <li>Agora é melhor do que nunca.
                            <ul><li>Embora nunca seja melhor que <i>agora mesmo</i>.</li></ul>
                            </li>
                            <li>Se a implementação é difícil de explicar, é uma péssima idéia.</li>
                            <li>Se a implementação é fácil de explicar, pode ser uma boa idéia.</li>
                            <li>Namespaces são uma grande idéia - vamos fazer mais desses!</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>As Esquisitices de Python</h2>
                    </section>

                    <section>
                        <h3>PEP8</h3>
                    </section>

                    <section>
                        <ol>
                            <li>PEPs (Python Enhancement Proposal) são as RFCs que os desenvolvedores
                            Python utilizam para comunicar novas funcionalidades.
                            <ul>
                                <li>Todos os PEPs podem ser encontados em
                                <a href='http://legacy.python.org/dev/peps/'>http://legacy.python.org/dev/peps/</a>.</li>
                            </ul>
                            <li>Uma funcionalidade não é simplesmente "aceita": É preciso escrever
                            uma proposta de melhoria explicando o problema encontra e como corrigí-lo.
                            </li>
                            <li>PEP8 define a melhor forma de se programar em Python.</li>
                            <li>PEP8 não é forçado pelo compilador.</li>
                            <li>PEP8 garante que qualquer programador Python consiga facilmente
                            encontrar coisas em códigos criados por terceiros.</li>
                        </ol>
                    </section>

                    <section>
                        <h4>Um pouco do PEP8:</h4>
                    </section>

                    <section>
                        <h5>Variáveis e funções utilizam a notação separado_por_underscores; classes
                            usam CamelCase.</h5>

                        <p>Correto:</p>

                        <pre><code class="hljs">
MinhaClasse

minha_funcao()
                        </code></pre>

                        <p>Errado:</p>

                        <pre><code class="hljs">
minhaClasse

minhaFuncao()
                        </code></pre>

                        <pre><code class="hljs fragment">
CONSTANTES
                        </code></pre>
                    </section>

                    <section>
                        <h5>Blocos são marcados com 4 espaços e não tabulações.</h5>

                        <p>A maior parte dos editores de código hoje permitem configurar isso facilmente
                        e fazem com que os 4 espaços no começo sejam tratados como tabulação.</p>

                        <p>Isso garante que o código irá sempre aparecer da mesma forma em qualquer
                        editor, não importando a configuração do autor.</p>
                    </section>

                    <section>
                        <h5>Coluna máxima é 80.</h5>

                        <p>Nenhum código deve passar da coluna 80, não importa o tamanho do seu
                        monitor.</p>

                        <p>Facilita a leitura e a movimentação dentro do código.</p>
                    </section>

                    <section>
                        <h5>Duas linhas em branco antes de classes, 1 linha em branco antes de funções.</h5>
                    </section>

                    <section>
                        <h5>Espaços entre operadores (+, -, /, *), nada de espaços antes de parentêses, colchetes ou chaves.</h5>

                        <p>Correto:</p>

                        <pre><code class="hljs">
(1 + 2)
array[1]
                        </code></pre>

                        <p>Errado:</p>

                        <pre><code class="hljs">
(1+2)
( 1 + 2 )
array [ 1 ]
                        </code></pre>
                    </section>

                    <section>
                        <h5>Nada de espaços entre parâmetros nomeados.</h5>

                        <p>Correto:</p>

                        <pre><code class="hljs">
funcao(param=1)
                        </code></pre>

                        <p>Errado:</p>

                        <pre><code class="hljs">
funcao(param = 1)
                        </code></pre>
                    </section>

                    <section>
                        <h3>Blocos</h3>
                    </section>

                    <section>
                        <p>Em Python, uma identação define um bloco.</p>

                        <p class='fragment'>Não existe <code>{</code> / <code>}</code>, não existe <code>end</code>, nada. Só identação.</p>

                        <img class='fragment' src='_images/zuul.jpg'></img>
                    </section>

                    <section>
                        <p>Um bloco sem nada dentro (por algum motivo), deve ser preenchido com,
                        pelo menos, <code>pass</code>.</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>O interpretador Python</h2>
                    </section>

                    <section>
                        <pre><code data-trim class='hljs'>
$ python

Python 2.7.5 (default, Jun 25 2014, 10:19:55)
[GCC 4.8.2 20131212 (Red Hat 4.8.2-7)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
                        </code></pre>

                        <p class="fragment">
                            Python 2 (todas as versões), deixarão de ser
                            suportadas em 2020!
                        </p>
                    </section>

                    <section>
                        <p>Executando scripts Python:</p>

                        <p><pre><code data-trim>
python meuscript.py
                        </code></pre></p>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Tipos de Variáveis</h2>
                    </section>

                    <section>
                        <h3>Tipos Mutáveis e Tipos Imutáveis</h3>

                        <p>Em Python, o tipo da variável pode ser mutável ou imutável, mas
                        a definição é data pelo tipo e não pelo usuário.</p>
                    </section>

                    <section>
                        <p>Uma variável do tipo "imutável" não pode ser alterada depois de
                        criada. Tentar modificar o conteúdo da variável vai criar uma nova
                        instância.</p>

                        <p>Uma variável do tipo "mutável" é o contrário: tentar alterar vai
                        alterar o objeto, não criar um novo.</p>

                        <p>A importância disto será visto mais pra frente, mas tenha isso
                        em mente.</p>
                    </section>

                    <section>
                        <p>... ainda...</p>

                        <p>Existem tipos que são, na verdade, objetos e tem toda uma gama
                        de funções para alterar/manipular/editar o conteúdo de uma variável.</p>

                        <p>Outros são tipos simples que não são objetos.</p>
                    </section>

                    <section>
                        <p><code>None</code>: O nada. Tipo simples.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = None
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>bool</code>: Tipo booleano. Tipo simples.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = True
&gt;&gt;&gt; b = False
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>int</code>: Um inteiro. Simples.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 1
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>float</code>: Um número com ponto flutuante. Simples.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 1.1
&gt;&gt;&gt; b = 1.0
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>str</code>: Strings. Objeto imutável.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 'Python'
&gt;&gt;&gt; b = "Python"
&gt;&gt;&gt; c = """Python
... Rocks!"""
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>unicode</code>: Strings em Unicode. Objeto imutável.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = u'Python'
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>list</code>: Listas. Objeto mutável.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = [1, 2, 'Python', ['Outra lista']]
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>dict</code>: Um dicionário/objeto/mapa/documento. Objeto mutável.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = {'Python': 'Rocks',
...      1: 1.0}
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>tuple</code>: Um conjunto de elementos. Objeto imutável.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = ('Python', 1)
&gt;&gt;&gt; b = (2,)
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>set</code>: Conjunto de elementos não repetíveis. Objeto mutável.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = set()
&gt;&gt;&gt; a.add('a')
&gt;&gt;&gt; a
set(['a'])
&gt;&gt;&gt; a.add('a')
&gt;&gt;&gt; a
set(['a'])

                        </code></pre></p>
                    </section>

                    <section>
                        <p>E ainda (mas menos importantes):</p>

                        <ul>
                            <li>Long (<code>a = 1L</code>)</li>
                            <li>Lambdas (<code>a = lambda a: a + 2</code>)</li>
                            <li>Raw strings (<code>r'string\s'</code>, usadas para regex)</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Estruturas de Controle</h2>

                        <p><small>(... que é o nome bonito para coisas tipo <code>if</code>, <code>for</code>...)</small></p>
                    </section>

                    <section>
                        <h3><code>if [condição]</code></h3>

                        <p><pre><code data-trim>
&gt;&gt;&gt; if a == 1:
...     b = 2
&gt;&gt;&gt; c = 3
                        </code></pre></p>
                    </section>

                    <section>
                        <h3><code>while [condição]</code></h3>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 1
&gt;&gt;&gt; while True:
...     a += 1
...     if a &gt; 10:
...         break
                        </code></pre></p>
                    </section>

                    <section>
                        <img src='_images/intermission_3696.jpg'>
                    </section>

                    <section>
                        <h3>[condição]</h3>

                        <p>Comparação pode ter mais de um elemento:</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 1; b = 5; c = 3; d = 1
&gt;&gt;&gt; a == b == c == d
False
&gt;&gt;&gt; a &lt; b &gt; c
True
                        </code></pre></p>
                    </section>

                    <section>
                        <h3>[condição] (cont.)</h3>

                        <p>Valores "em branco" são considerados falsos:</p>

                        <ul>
                            <li><code>None</code> é falso.</li>
                            <li><code>""</code>, string vazia, é falso.</li>
                            <li><code>0</code> é falso em qualquer precisão.</li>
                            <li><code>[]</code>, lista vazia, é falso.</li>
                            <li><code>{}</code>, dicionário vazio, é falso.</li>
                            <li><code>set()</code>, set vazio, é falso.</li>
                        </ul>
                    </section>

                    <section>
                        <h3>[condição] (cont.)</h3>

                        <p>Como valores em branco são falsos, para garantir <code>None</code>
                        usa-se <code>is</code>.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 0
&gt;&gt;&gt; not a
True
&gt;&gt;&gt; a is None
False
&gt;&gt;&gt; a = None
&gt;&gt;&gt; not a
True
&gt;&gt;&gt; a is None
True
                        </code></pre></p>
                    </section>

                    <section>
                        <img src='_images/tumblr_n6qbpoBDVX1rbyj0do1_500.jpg'>
                    </section>

                    <section>
                        <h3><code>for [iterável]</code></h3>

                        <p><pre><code data-trim>
&gt;&gt;&gt; soma = 0
&gt;&gt;&gt; for valor em [345, 123, 123, 34]:
...     soma += valor
                        </code></pre></p>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>The fuck "ITERÁVEL"?</h2>
                    </section>

                    <section>
                        <p>Um objeto "iterável" é aquele que pode ter elementos
                        acessados usando <code>[</code> e <code>]</code>.</p>
                    </section>

                    <section>
                        <p>Tipos iteráveis:</p>

                        <ul>
                            <li class='fragment'>Listas (<code>a[2]</code>)</li>
                            <li class='fragment'>Tuplas (<code>a[2]</code>)</li>
                            <li class='fragment'>Dicionários (<code>a['Python']</code>)</li>
                            <li class='fragment'>Strings/Unicodes (<code>a[2]</code>)</li>
                        </u>
                    </section>

                    <section>
                        <p>Strings como iteráveis:</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; for l in 'Python':
...     print l
                        </code></pre></p>
                    </section>

                    <section>
                        <p>Dicionários como iteráveis:</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; d =  {'Python': 'Rocks', 'Parrot': 'Dead', 'Favorite Color': 'Blue'}
&gt;&gt;&gt; for key in d:
...    print key, d[key]
                        </code></pre></p>
                    </section>

                    <section>
                        <p>Ou ainda:</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; d =  {'Python': 'Rocks', 'Parrot': 'Dead', 'Favorite Color': 'Blue'}
&gt;&gt;&gt; for (key, value) in d.iteritems():
...     print key, value
                        </code></pre></p>

                        <p class='fragment'>Forma considerada "correta" é a anterior.</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Slices</h2>
                    </section>

                    <section>
                        <p>Slice é uma "extensão" de indíces de acesso.</p>

                        <p>Com slices, é possível "cortar" iteráveis, retornando
                        um novo iterável.</p>
                    </section>

                    <section>
                        <p><pre><code data-trim>
iterável[start:end:step]
                        </code></pre></p>

                        <p>(<code>end</code> é exclusívo.)</p>
                    </section>

                    <section>
                        <p><pre><code data-trim>
&gt;&gt;&gt; a = [1, 2, 3, 4]
... print a[1:2]
[2]
                        </code></pre></p>
                    </section>

                    <section>
                        <p>Deixar um índice em branco indica que:</p>

                        <ul>
                            <li><code>start</code> = 0</li>
                            <li><code>end</code> = len(iterável)</li>
                            <li><code>step</code> = 1</li>
                        </ul>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = [1, 2, 3, 4]
... print a[:2]
[1, 2]
                        </code></pre></p>
                    </section>

                    <section>
                        <p>Índices negativos começam do final do iterável.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = [1, 2, 3, 4]
... print a[1:-1]
[2, 3]
                        </code></pre></p>
                    </section>

                    <section>
                        <p>Lembre-se que strings também são iteráveis.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 'Python Rocks'
... print a[7:-1]
'Rock'
                        </code></pre></p>
                    </section>

                    <section>
                        <p>Deixar os dois índices em branco cria uma cópia "flat".</p>
                        <p><pre><code data-trim>
&gt;&gt;&gt; a = [1, 2, 3, 4]
... print a[:]
[1, 2, 3, 4]
                        </code></pre></p>

                        <p>Para fazer uma cópia de uma lista com outros
                        iteráveis internos, existe o módulo <code>deepcopy</code>.</p>
                    </section>

                    <section>
                        <p>Todos os iteráveis podem ser "medidos" com <code>len()</code>:</p>

                        <ul>
                            <li><code>len(list)</code> &#8667; Número de elementos na lista.</li>
                            <li><code>len(tuple)</code> &#8667; Número de elementos na tupla.</li>
                            <li><code>len(str)</code> &#8667; Número de caracteres na string.</li>
                            <li><code>len(dict)</code> &#8667; Número de chaves no dicionário.</li>
                            <li><code>len(set)</code> &#8667; Número de elementos no set.</li>
                        </ul>

                    </section>
                </section>

                <section>
                    <section>
                        <h2>Funções</h2>
                    </section>

                    <section>
                        <h3><code>def [nome_da_função]([parâmetro], [parâmetro], ...):</code></h3>

                        <p><pre><code data-trim>
&gt;&gt;&gt; def funcao(a, b, c):
...     return (a + b) / c
                        </code></pre></p>
                    </section>

                    <section>
                        <p>Parâmetros podem ser nomeados.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; def funcao(a, b, c):
...     return (a + b) / c
&gt;&gt;&gt;
&gt;&gt;&gt; funcao(b=2, c=3, a=10)
4
                        </code></pre></p>
                    </section>

                    <section>
                        <h3>Funções podem conter funções</h3>

                        <pre><code class="hljs">
&gt;&gt;&gt; def funcao(a, b):
...    def inner(b):
...        return b * 2 if b &gt; 0 else b * -2
...    return inner(a) + b
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Classes</h2>
                    </section>

                    <section>
                        <p>Ok, algumas coisas a serem vistas antes de entrar em
                        classes:</p>
                    </section>

                    <section>
                        <p>Existem dois tipos de classes: old-style e new-style.</p>

                        <p>A diferença é que classes "new-style" sempre extendem da
                        classe <code>object</code>, enquanto que "old-style" não
                        extendem ninguém.</p>

                        <p>Por baixo dos panos, "new-style" e "old-style" funcionam
                        de forma diferente, mas isso não é visível para o
                        programador.</p>
                    </section>

                    <section>
                        <p>Para todos os casos e efeitos, "old-style" não deve
                        mais ser usado.</p>

                        <p class='fragment'>No Python 3, não existem mais
                        classes "old-style", mas a sintaxe removeu a necessidade
                        de extender <code>object</code>.</p>

                        <p class='fragment'>(Ou seja, no Python 3 uma classe
                        se parece com o "old-style" do Python 2.)</p>
                    </section>

                    <section>
                        <p><code>this</code>/<code>self</code> não é uma variável
                        implícita da classe: Ela tem que constar <i>sempre</i>
                        na definição do método.</p>
                    </section>

                    <section>
                        <p>O construtor da classe é chamado <code>__init__</code>.</p>

                        <p>Não existe função para o destrutor.</p>

                        <p class="fragment">(Existe, mas ninguém usa.)</p>

                        <p class='fragment'>Existem ainda outras funções
                            <i>mágicas</i>, mas não vamos falar sobre elas
                            nesse momento.</p> </section>

                    <section>
                        <p><pre><code data-trim>
&gt;&gt;&gt; class MyClasse(object):
...     def __init__(self):
...         self.valor = 0
...     def show(self):
...         print self.valor
                        </code></pre></p>
                    </section>

                    <section>
                        <p>Para instanciar uma classe, basta chamar a classe
                        como se fosse uma função.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; my = MyClasse()
&gt;&gt;&gt; my.show()
0
                        </code></pre></p>
                    </section>

                    <section>
                        <p>Se o construtor tiver parâmetros, estes devem ser
                        passados durante a instanciação, como se a "função"
                        classe tivesse parâmetros.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; class MyClasse(object):
...     def __init__(self, name):
...         self.name = name
...     def show(self):
...         print self.name

&gt;&gt;&gt; my = MyClasse('Julio')
&gt;&gt;&gt; my.show()
Julio
                        </code></pre></p>
                    </section>

                    <section>
                        <p>Propriedades podem ser injetadas a qualquer momento.</p>

                        <pre><code class="hljs">
&gt;&gt;&gt; class A(object):
...     def __init__(self):
...         self.value = 10
&gt;&gt;&gt;
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.name = 'Julio'
                        </code></pre>

                        <p class="fragment">Inserção de propriedades pode ser
                            barrada com o uso da variável mágica
                            <code>__slots__</code>, mas raramente é usado.</p>
                    </section>

                    <section>
                        <p>Herança</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; class A(object):
...     def __init__(self):
...         self.value = 10
&gt;&gt;&gt; class B(A):
...     def __init__(self):
...         super(B, self).__init__()
...         self.name = 'AAAA'
                        </code></pre></p>
                    </section>

                    <section>
                        <p>Herança Múltipla</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; class A(object):
...     def __init__(self):
...         self.value = 10
&gt;&gt;&gt; class B(object):
...     def __init__(self):
...         self.name = 'AAAA'
&gt;&gt;&gt; class C(A, B):
...     def __init__(self):
...         super(C, self).__init__()
                        </code></pre></p>
                    </section>

                    <section>
                        <p>No Python 3, basta usar <code>super().__init__()</code>.
                    </section>

                    <section>
                        <p><code>super()</code> é mais usado para resolução
                            hierárquia com herança múltipla.</p>
                    </section>

                    <section>
                        <pre><code class="hljs">
&gt;&gt;&gt; class Adao(object): pass
&gt;&gt;&gt; class Eva(object): pass
&gt;&gt;&gt; class AvoPaterno(Adao, Eva): pass
&gt;&gt;&gt; class AvohPaterna(Adao, Eva): pass
&gt;&gt;&gt; class AvoMaterno(Adao, Eva): pass
&gt;&gt;&gt; class AvohMaterna(Adao, Eva): pass
&gt;&gt;&gt; class Pai(AvoPaterno, AvohPaterna): pass
&gt;&gt;&gt; class Mae(AvoMaterno, AvohMaterna): pass
&gt;&gt;&gt; class Filho(Pai, Mae): pass
                        </code></pre>

                        <pre><code class="hljs">
&gt;&gt;&gt; help(Filho)
                        </code></pre>
                    </section>

                    <section>
                        <pre><code class="hljs">
Help on class Filho in module __main__:

class Filho(Pai, Mae)
 |  Method resolution order:
 |      Filho
 |      Pai
 |      AvoPaterno
 |      AvohPaterna
 |      Mae
 |      AvoMaterno
 |      AvohMaterna
 |      Adao
 |      Eva
 |      __builtin__.object
                        </code></pre>
                    </section>

                    <section>
                        <p>A ordem de resolução pode ser usada para inserir
                            mocks sem o uso de mocks.</p>

                        <p class="fragment">... embora só sirva para mockar
                            objetos "é um" e não "contém um".</p>
                    </section>

                    <section>
                        <pre><code class="hljs">
&gt;&gt;&gt; class Robo(object):
...    def pegar(self, ferramenta):
...        print 'Pegando', ferramenta
...    def pra_frente(self):
...        print 'Movendo pra frente'
...    def pra_tras(self):
...        print 'Voltando'
...    def largar(self):
...        print 'Largando ferramenta'
                        </code></pre>
                    </section>

                    <section>
                        <pre><code class="hljs">
&gt;&gt;&gt; class RoboDeLimpeza(Robo):
...    def clean(self, repeticoes=10):
...        super(Robo, self).pegar('vassoura')
...        for _ in xrange(repeticoes):
...            super(Robo, self).pra_frente()
...            super(Robo, self).pra_tras()
...        super(Robo, self).largar()
                        </code></pre>
                    </section>

                    <section>
                        <pre><code class="hljs">
&gt;&gt;&gt; class MockRobo(Robo):
...     def __init__(self):
...         self.acoes = []
...     def pegar(self, ferramenta):
...         self.acoes.append('Pegar {}'.format(ferramenta))
...     def pra_frente(self):
...         self.acoes.append('frente')
...     def pra_tras(self):
...         self.acoes.append('tras')
...     def largar(self):
...         self.acoes.append('largar')
                        </code></pre>
                    </section>

                    <section>
                        <pre><code class="hljs">
&gt;&gt;&gt; class MockRoboDeLimpeza(RoboDeLimpeza, MockRobo):
...     pass
                        </code></pre>
                    </section>

                    <section>
                        <pre><code class="hljs">
Help on class MockRoboDeLimpeza in module __main__:

class MockRoboDeLimpeza(RoboDeLimpeza, MockRobo)
 |  Method resolution order:
 |      MockRoboDeLimpeza
 |      RoboDeLimpeza
 |      MockRobo
 |      Robo
 |      __builtin__.object
                        </code></pre>
                    </section>

                    <section>
                        <p>
                            Mais informações no vídeo de Raymond Hettinger:
                            <a href='https://www.youtube.com/watch?v=EiOglTERPEo'>Super Considered super!</a>
                        </p>
                    </section>

                    <section>
                        <h3>Assim como funções, classes podem conter classes:</h3>

                        <pre><code class="hljs">
&gt;&gt;&gt; class Outer(object):
...    class Inner(object):
...        def __init__(self):
...            self.value = 1
...    def __init__(self):
...        self.value = Inner()
                        </code></pre>
                    </section>
                </section>

                <section>
                    <h2>Mais Esquisitices de Python</h2>
                </section>

                <section>
                    <section>
                        <h3>Strings São Imutáveis</h3>
                    </section>

                    <section>
                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 'string 1'
&gt;&gt;&gt; b = 'string 2'
&gt;&gt;&gt; c = a + ' ' + b
                        </code></pre></p>

                        <ul>
                            <li>Cria um objeto que é o conteúdo de "a" com um espaço.</li>
                            <li>Cria um novo objeto que é o novo objeto mais o conteúdo de "b".</li>
                            <li>Atribui o novo objeto à "c".</li>
                        </ul>
                    </section>

                    <section>
                        <p>Forma correta de concatenar strings:</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 'string 1'
&gt;&gt;&gt; b = 'string 2'
&gt;&gt;&gt; c = ' '.join([a, b])
                        </code></pre></p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Listas São Mutáveis</h3>
                    </section>

                    <section>
                        <p><pre><code data-trim>
&gt;&gt;&gt; def a(l=[]):
...     l.append(1)
...     print l
&gt;&gt;&gt; a()
[1]
&gt;&gt;&gt; a()
[1, 1]
                        </code></pre></p>
                    </section>

                    <section>
                        <p>Forma correta de lidar com parâmetros mutáveis:</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; def a(l=None):
...     if not l:
...         l = []
...     l.append(1)
&gt;&gt;&gt; a()
[1]
&gt;&gt;&gt; a()
[1]
                        </code></pre></p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Stars</h3>
                    </section>

                    <section>
                        <p>"Stars" servem para empacotar e desempacotar parâmetros indefinidos.</p>
                    </section>

                    <section>
                        <p><pre><code data-trim>
&gt;&gt;&gt; def a(*args):
...     print args
&gt;&gt;&gt; a(1)
[1]
&gt;&gt;&gt; a(1, 2, 3, 4, 5)
[1, 2, 3, 4, 5]
                        </code></pre></p>

                        <p><code>*</code> pega somente os parâmetros que não tem nome.</p>
                    </section>

                    <section>
                        <p><pre><code data-trim>
&gt;&gt;&gt; def a(**kwargs):
...     print kwargs
&gt;&gt;&gt; a(a=1)
{'a': 1}
&gt;&gt;&gt; a(value1=10, a=2)
{'value1': 10, 'a': 2}
                        </code></pre></p>

                        <p><code>**</code> pega somente os parâmetros que tem nome.</p>
                    </section>

                    <section>
                        <p><pre><code data-trim>
&gt;&gt;&gt; def a(*args, **kwargs):
...     print args
...     print kwargs
&gt;&gt;&gt; a(a=1)
[]
{'a': 1}
&gt;&gt;&gt; a(1, 2, 3, a=5)
[1, 2, 3]
{'a': 5}
                        </code></pre></p>
                    </section>

                    <section>
                        <p><pre><code data-trim>
&gt;&gt;&gt; def a(a, b, *args, name=None, **kwargs):
...     print 'a =', a
...     print 'b =', b
...     print 'args =', args
...     print 'name = ', name
...     print 'kwargs =', kwargs
                        </code></pre></p>

                        <p>Saída de uma chamada desta função fica a cargo do leitor.</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3><code>for</code> tem <code>else</code></h3>
                    </section>

                    <section>
                        <pre><code class="hljs">
&gt;&gt;&gt; for i in xrange(10):
...     if i == 1:
...         break
... else:
...     print 'Oh no'
                        </code></pre>

                        <p class="fragment">WAT</p>
                    </section>

                    <section>
                        <h3><code>for</code> tem <code>else</code></h3>

                        <p><code>else</code> é chamado se a execução do loop
                            chegar ao final.</p>

                        <pre><code class="hljs">
&gt;&gt;&gt; for record in all_content:
...     if record.name = search:
...         found = record
...         break
... else:
...     found = None
                        </code></pre>
                    </section>
                </section>

                </section>
                    <section>
                        <h3><code>try</code> tem <code>else</code></h3>
                    </section>

                    <section>
                        <pre><code class="hljs">
&gt;&gt;&gt; try:
...    func_that_raises_exception()
... else:
...     print 'Yay!'
                        </code></pre>

                        <p class="fragment"><code>else</code> é chamado quando
                            exceções não ocorrerem.</p>

                        <p class="fragment"><code>finally</code>
                            <strong>SEMPRE</strong> é chamado.</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>"Functions are First Class Citizens"</h3>
                    </section>

                    <section>
                        <p><pre><code data-trim>
&gt;&gt;&gt; def funcao(a, b, c):
...     return (a + b) / c
&gt;&gt;&gt; def check(a, b, c, condition, function):
...     if condition:
...         print function(a, b, c)
&gt;&gt;&gt; check(1, 2, 3, True, funcao)
1
&gt;&gt;&gt; check(1, 2, 3, False, funcao)
&gt;&gt;&gt;
                        </code></pre></p>
                    </section>

                    <section>
                        <p>Como funções são cidadãos de primeira classe e classes podem
                        ter funções injetadas, pode-se extender uma classe em tempo
                        de execução.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; class A(object):
...     def __init__(self):
...         self.value = 10
... def show_name(self):
...     print 'Julio'
&gt;&gt;&gt; a = A()
&gt;&gt;&gt; a.show = show_name
&gt;&gt;&gt; a.show()
                        </code></pre></p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Decorators</h3>
                    </section>

                    <section>
                        <p>A idéia dos decorators é cria uma função que altera a funcionalidade
                        de uma função.</p>

                        <p>A forma mais simples de entender decorators é pensar neles como
                        funções que encapsulam callbacks.</p>
                    </section>

                    <section>
                        <p><pre><code data-trim>
&gt;&gt;&gt; def retrieve(connection):
...     # faz algo com a conexão para recuperar dados.
                        </code></pre></p>

                        <p>Problema: antes de sair executando algo na conexão, tem que ser
                        verificado se a conexão está ativa.</p>
                    </section>

                    <section>
                        <p>Solução menos óbvia: Criar uma função que verifica a conexão e,
                        se ela estiver ok, chama a função.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; def retrieve(connection):
...     # faz algo com a conexão para recuperar dados.

&gt;&gt;&gt; def update(connection):
...     # atualiza algo usando a função

&gt;&gt;&gt; def check(connection, call):
...     if not connection.is_connected:
...         connection.retry()
...     call(connection)
                        </code></pre></p>

                        <p>Novo problema: Todo lugar onde antes era chamado <code>retrieve</code>
                        agora precisa ser alterado para <code>check(connection, retrieve)</code> e
                        todo lungar onde era chamado <code>update</code> precisa ser alterado para
                        <code>check(connection, update)</code>.</p>
                    </section>

                    <section>
                        <p>Solução mais simples: decorators.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; from functools import wrap
&gt;&gt;&gt; def check(func):
...     def check_conn(*args, **kwargs):
...         # acha a conexão em args ou kwargs
...         if not connection.is_connected:
...             connection.retry()
...         return func(*args, **kwargs)
...     return check_conn

&gt;&gt;&gt; @check
&gt;&gt;&gt; def retrieve(connection):
...     # faz algo com a conexão para recuperar dados
                        </code></pre></p>

                        <p>Não precisa alterar nenhuma chamada de <code>retrieve</code>.</p>
                    </section>

                    <section>
                        <p>Lembre-se: O resultado de uma função decorator é uma função.</p>
                    </section>

                    <section>
                        <h5>Decorators com classes</h5>

                        <pre><code class="hljs">
&gt;&gt;&gt; class CheckConn(object):
...    def __init__(self, func):
...        self.func = func
...
...     def __call__(self, *args, **kwargs):
...         if 'connection' in kwargs:
...             connection = kwargs['connection']
...         else:
...             connection = args[0]
...
...         if not connection.is_connected:
...             connection.retry()
...         self.func(*args, **kwargs)

&gt;&gt;&gt; @CheckCon
&gt;&gt;&gt; def retrieve(connection):
...     # retrieve
                        </code></pre>
                    </section>

                    <section>
                        <h5>Decorators mais comuns:</h5>

                        <ul>
                            <li><code>@property</code></li>
                            <li><code>@staticmethod</code></li>
                        </ul>
                    </section>

                    <section>
                        <h5><code>@property</code></h5>

                        <pre><code class='hljs'>
&gt;&gt;&gt; class CheckConn(object):
...    def __init__(self, func):
...        self._func = func
...
...    @property
...    def func(self):
...        return self._func
...
...    @func.setter
...    def func(self, value):
...        self._func = func
                        </code></pre>
                    </section>

                    <section>
                        <h5><code>@staticmethod</code></h5>

                        <pre><code class='hljs'>
&gt;&gt;&gt; class CheckConn(object):
...    def __init__(self, func):
...        self._func = func
...
...    @staticmethod
...    def from_text(self, text):
...        return CheckConn(getattr(self, text))
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Comprehensions e Generators</h3>

                        <p>Python permite criar listas processando listas sem
                            <code>for</code> com <i>list
                                comprehensions</i>.</p>

                        <pre><code class="hljs">
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; [item * 2 for item in a]
&gt;&gt;&gt; [2, 4, 6]
                        </code></pre>

                        <p>Pra quem gosta de coisas "funcionais", é o mesmo que
                            <code>map</code>.</p>

                        <pre><code class="hljs">
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; map(lamba f: f * 2, a)
&gt;&gt;&gt; [2, 4, 6]
                        </code></pre>
                    </section>

                    <section>
                        <h4>Comprehensions (contd.)</h4>
                        <p>É possível filtrar elementos com list comprehensions.</p>

                        <pre><code class="hljs">
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; [item for item in a if item > 2]
&gt;&gt;&gt; [3]
                        </code></pre>

                        <p>Funcionalmente, é o mesmo que <code>filter</code>.</p>

                        <pre><code class="hljs">
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; filter(lambda f: f > 2, a)
&gt;&gt;&gt; [3]
                        </code></pre>
                    </section>

                    <section>
                        <h4>Generators</h4>

                        <p>Enquanto que comprehensions criam novas listas, generators
                        geram elementos sob demanda.</p>

                        <pre><code class="hljs">
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; (item * 2 for item in a)
&lt;generator object &lt;genexpr&gt; at 0x7f8673dfc050&gt;
                        </code></pre>
                    </section>

                    <section>
                        <h5>Generators (contd.)</h5>

                        <pre><code class="hljs">
&gt;&gt;&gt; [item for item in range(5000000)]
                        </code></pre>

                        <p>vs</p>

                        <pre><code class="hljs">
&gt;&gt;&gt; (item for item in xrange(5000000))
                        </code></pre>
                    </section>

                    <section>
                        <h5>Generators (contd.)</h5>

                        <pre><code class="hljs">
&gt;&gt;&gt; [item for item in range(5000000)][:5]
                        </code></pre>

                        <p>vs</p>

                        <pre><code class="hljs">
&gt;&gt;&gt; (item for item in xrange(5000000))[:5]
                        </code></pre>
                    </section>

                    <section>
                        <h5>Generators (contd.)</h5>

                        <pre><code class="hljs">
&gt;&gt;&gt; def gen(max_value):
...    for value in xrange(max_value):
...        yield value * 2
                        </code></pre>

                        <p>Generator functions não podem ter <code>return</code>!</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Context Managers</h3>

                        <p>
                            <i>Context Managers</i> são usados como "marcadores"
                            para entrada e saída de pontos específicos.
                        </p>
                    </section>

                    <section>
                        <h3>Context Managers</h3>

                        <pre><code class="hljs">
&gt;&gt;&gt; class Connection(object):
...    def __init__(self):
...        self._conn = None
...
...    def __enter__(self):
...        self._conn = self._make_connection()
...        return self._conn
...
...    def __exit__(self, exc_type, exc_value, traceback):
...        self._conn.close()
...        if exc_type:    # then exc_value and traceback
...            print "Exception!", exc_type, exc_value
...            print traceback
                        </code></pre>

                        <pre><code class="hljs">
&gt;&gt;&gt; with Connection() as connection:
...     connection.request('Value')
                        </code></pre>
                    </section>

                    <section>
                        <h3>Context Managers vs Exceptions</h3>

                        <pre><code class="hljs">
&gt;&gt;&gt; try:
...     conn = self._make_connection()
...     conn.request('value')
... finally:
...     conn.close()
... except Exception as exc:  # Bare exceptions are BAAAADDD!
...     print 'Exception!', exc
                        </code></pre>
                    </section>

                </section>

                <section>
                    <section>
                        <h3>Docstrings</h3>

                        <p>Documentação de funções/classes é feita com uma string
                            logo abaixo da declaração da mesma.</p>

                        <pre><code class="hljs">
&gt;&gt;&gt; def func(a):
...     """Função mágica"""
...     return a

&gt;&gt;&gt; print func.__doc__
Função mágica

&gt;&gt;&gt; help(func)
                        </code></pre>
                    </section>

                    <section>
                        <h4>Sphinx</h4>

                        <p>Sphinx é o sistema de geração de documentação do Python.</p>

                        <img src="_images/sphinx.png" alt=""/>
                    </section>

                    <section>
                        <h4>PEP 257</h4>

                        <p>PEP 257 fala sobre formato de documentação de funções.</p>
                    </section>

                    <section>
                        <h5>PEP 257</h5>

                        <ul>
                            <li>Docstrings devem ter três aspas duplas.</li>
                            <li>Para classes, uma linha em branco antes e uma depois.</li>
                            <li>Para funções, sempre logo depois.</li>
                            <li>Se a documentação passar da coluna 80, as três
                                aspas que fecham a docstring devem ficar em uma
                                linha em separado.</li>
                        </ul>

                        <pre><code class="hljs">
class MyClass(object):

    """This is my class. It is very long and I should break it
    into several lines.
    """

    def __init__(self):
        """Initialization."""
        self.value = None
                        </code></pre>
                    </section>

                    <section>
                        <h4>Sphinx Format</h4>

                        <p>O Sphinx tem um formato específico para documentação.</p>

                        <ul>
                            <li>Parametros são documentados com <code>:param [nome]:</code></li>
                            <li>Tipo do parametro é documetnado com <code>:type [tipo]:</code></li>
                            <li>Retorno é marcado como <code>:return:</code></li>
                            <li>Tipo de retorno é definido em <code>:rtype:</code></li>
                            <li>Exceções podem ser descritas em <code>:raises [exceção]:</code></li>
                        </ul>
                    </section>

                    <section>
                        <h4>Sphinx Format (contd.)</h4>

                        <pre><code class="hljs">
def send(sender, recipient, message_body, priority):
   """Send a message to a recipient

   :param str sender: The person sending the message
   :param str recipient: The recipient of the message
   :param str message_body: The body of the message
   :param priority: The priority of the message, can be a number 1-5
   :type priority: integer or None
   :return: the message id
   :rtype: int
   :raises ValueError: if the message_body exceeds 160 characters
   :raises TypeError: if the message_body is not a basestring
   """
   pass
                        </code></pre>
                    </section>

                    <section>
                        <p>(como gerar documentação Sphinx não será apresentado por
                            questões de espaço.)</p>

                        <p class="fragment">(mas é simples: um arquivo conf com os
                            diretórios a serem pesquisados e um makefile com a opção
                            html para geração de arquivos HTML.)</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>VirtualEnv</h3>
                    </section>
                </section>

                <section data-background='_images/thats-all-folks.jpg'>
                    <section></section>
                </section>
            </div>
        </div>

        <script src="reveal.js/lib/js/head.min.js"></script>
        <script src="reveal.js/js/reveal.js"></script>

        <script>
            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.configure({languages: ['python']}); hljs.initHighlightingOnLoad(); } },
                    { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
                    { src: 'reveal.js/plugin/notes/notes.js', async: true }
                ]
            });

        </script>
    </body>
</html>
