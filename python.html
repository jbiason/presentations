<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Python</title>

        <meta name="author" content="Julio Biason">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <link rel="stylesheet" href="_external/reveal.min.css">
        <link rel="stylesheet" href="_external/default.css" id="theme">

        <!-- For syntax highlighting -->
        <link rel="stylesheet" href="_external/zenburn.css">

        <!-- If the query includes 'print-pdf', include the PDF print sheet -->
        <script>
            if( window.location.search.match( /print-pdf/gi ) ) {
                var link = document.createElement( 'link' );
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_external/pdf.css';
                document.getElementsByTagName( 'head' )[0].appendChild( link );
            }
        </script>

        <!--[if lt IE 9]>
        <script src="reveal.js/lib/js/html5shiv.js"></script>
        <![endif]-->

        <style>
.semi-opaque {
    background-color: rgba(0, 0, 0, 0.7);
}

* {
    hyphens: none !important;
    -moz-hyphens: none !important;
}
        </style>
    </head>

    <body>

        <div class="reveal">
            <div class="slides">
                <section data-background='_images/zen-of-python-poster-a3.png' class='semi-opaque'>
                    <h1>Python</h1>
                </section>

                <section>
                    <section>
                        <h2>O que é Python?</h2>
                    </section>

                    <section>
                        <ul>
                            <li>Linguagem interpretada.</li>
                            <li>Dinamicamente tipada.</li>
							<li>Principais usos em pesquisas e web.</li>
                        </ul>
                    </section>
				</section>

				<section>
                    <section>
                        <h2>O Zen de Python</h2>
					</section>
                        
					<section>
                        <ul>
                            <li>Bonito é melhor que feio.</li>
                            <li>Explícito é melhor que implícito.</li>
                            <li>Simples é melhor que complexo.</li>
                            <li>Complexo é melhor que complicado.</li>
                            <li>Plano é melhor que aninhado.</li>
                            <li>Esparço é melhor que denso.</li>
                            <li>Legibilidade conta.</li>
                        </ul>
                    </section>
                    
                    <section>
                        <ul>
                            <li>Casos especiais não são especiais o suficiente para quebrar as regras.
							<ul><li>Embora praticabilidade ganhe de puridade.</li></ul>
							</li>
                            <li>Erros nunca devem passam silenciosamente.
							<ul><li>A não ser que sejam explicitamente silenciados.</li></ul>
							</li>
                            <li>Em caso de ambiguidade, evite a tentação de adivinhar.</li>
                            <li>Deve haver um -- e preferencialmente apenas um -- modo óbvio de fazer algo.
							<ul><li>Embora talvez não seja tão óbvio de primeira a não ser que você seja Holandês.</li></ul>
							</li>
                        </ul>
                    </section>
                    
                    <section>
                        <ul>
                            <li>Agora é melhor do que nunca.
							<ul><li>Embora nunca seja melhor que <i>agora mesmo</i>.</li></ul>
							</li>
                            <li>Se a implementação é difícil de explicar, é uma péssima idéia.</li>
                            <li>Se a implementação é fácil de explicar, pode ser uma boa idéia.</li>
                            <li>Namespaces são uma grande idéia - vamos fazer mais desses!</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>O interpretador Python</h2>
                    </section>

                    <section>
                        <p><pre><code data-trim>
Python 2.7.5 (default, Jun 25 2014, 10:19:55) 
[GCC 4.8.2 20131212 (Red Hat 4.8.2-7)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
                        </code></pre></p>
                    </section>
                    
                    <section>
                        <p>Executando scripts Python:</p>
                        
                        <p><pre><code data-trim>
python meuscript.py
                        </code></pre></p>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Tipos de Variáveis</h2>
                    </section>
                    
                    <section>
                        <h3>Tipos Mutáveis e Tipos Imutáveis</h3>

                        <p>Em Python, o tipo da variável pode ser mutável ou imutável, mas
                        a definição é data pelo tipo e não pelo usuário.</p>
                    </section>

                    <section>
                        <p>Uma variável do tipo "imutável" não pode ser alterada depois de
                        criada. Tentar modificar o conteúdo da variável vai criar uma nova
                        instância.</p>

                        <p>Uma variável do tipo "mutável" é o contrário: tentar alterar vai
                        alterar o objeto, não criar um novo.</p>

                        <p>A importância disto será visto mais pra frente, mas tenha isso
                        em mente.</p>
                    </section>
                    
                    <section>
                        <p>... ainda...</p>
                        
                        <p>Existem tipos que são, na verdade, objetos e tem toda uma gama
                        de funções para alterar/manipular/editar o conteúdo de uma variável.</p>
                        
                        <p>Outros são tipos simples que não são objetos.</p>
                    </section>

                    <section>
                        <p><code>bool</code>: Tipo booleano. Tipo simples.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = True
&gt;&gt;&gt; b = False
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>int</code>: Um inteiro. Simples.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 1
                        </code></pre></p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; 1 + 1
2
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>float</code>: Um número com ponto flutuante. Simples.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 1.1
&gt;&gt;&gt; b = 1.0
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>str</code>: Strings. Objeto imutável.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 'Python'
&gt;&gt;&gt; b = "Python"
&gt;&gt;&gt; c = """Python
&gt;&gt;&gt; Rocks!"""
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>unicode</code>: Strings em Unicode. Objeto imutável.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = u'Python'
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>list</code>: Listas. Objeto mutável.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = [1, 2, 'Python', ['Outra lista']]
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>dict</code>: Um dicionário/objeto/mapa. Objeto mutável.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = {'Python': 'Rocks',
&gt;&gt;&gt; 1: 1.0}
                        </code></pre></p>
                    </section>

                    <section>
                        <p><code>tuple</code>: Um conjunto de elementos. Objeto imutável.</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = ('Python', 1)
&gt;&gt;&gt; b = (2,)
                        </code></pre></p>
                    </section>

                    <section>
                        <p>E ainda (mas menos importantes):</p>

                        <ul>
                            <li>None</li>
                            <li>Long (<code>a = 1L</code>)</li>
                            <li>Lambdas (<code> a = lambda a: a + 2</code>)</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Estruturas de Controle</h2>

                        <p><small>(... que é o nome bonito para coisas tipo <code>if</code>, <code>for</code>...)</small></p>
                    </section>

                    <section>
                        <p>Antes de mais nada...</p>

                        <h3 class='fragment'>Blocos</h3>
                    </section>

                    <section>
                        <p>Em Python, uma identação define um bloco.</p>

                        <p class='fragment'>Não tem <code>{</code> / <code>}</code>, não tem <code>end</code>, nada. Só blocos.</p>

                        <img class='fragment' src='_images/zuul.jpg'></img>
                    </section>

                    <section>
                        <h3><code>if [condição]</code></h3>

                        <p><pre><code data-trim>
&gt;&gt;&gt; if a == 1:
&gt;&gt;&gt;     b = 2
&gt;&gt;&gt; c = 3
                        </code></pre></p>
                    </section>

                    <section>
                        <h3><code>while [condição]</code></h3>

                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 1
&gt;&gt;&gt; while True:
&gt;&gt;&gt;     a += 1
&gt;&gt;&gt;     if a &gt; 10:
&gt;&gt;&gt;         break
                        </code></pre></p>
                    </section>

                    <section>
                        <h3><code>for [iterável]</code></h3>

                        <p><pre><code data-trim>
&gt;&gt;&gt; soma = 0
&gt;&gt;&gt; for valor em [345, 123, 123, 34]:
&gt;&gt;&gt;     soma += valor
                        </code></pre></p>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>The fuck "ITERÁVEL"?</h2>
                    </section>

                    <section>
                        <p>Um objeto "iterável" é aquele que pode ter elementos
                        acessados usando <code>[</code> e <code>]</code>.</p>

						<p class='fragment'>(Na verdade, o objeto tem que ter um <i>generator</i>;
						para acesar elementos diretamente, o objeto tem que implementar a função
						<code>__getitem__</code>.)</p>
                    </section>

                    <section>
                        <p>Tipos iteráveis:</p>

                        <ul>
                            <li class='fragment'>Listas (<code>a[2]</code>)</li>
                            <li class='fragment'>Tuplas (<code>a[2]</code>)</li>
                            <li class='fragment'>Dicionários (<code>a['Python']</code>)</li>
                            <li class='fragment'>Strings/Unicodes (<code>a[2]</code>)</li>
                        </u>
                    </section>

                    <section>
                        <p>Strings como iteráveis:</p>

                        <p><pre><code data-trim>
&gt;&gt;&gt; for l in 'Python':
&gt;&gt;&gt;     print l
                        </code></pre></p>
                    </section>

					<section>
						<p>Dicionários como iteráveis:</p>

						<p><pre><code data-trim>
&gt;&gt;&gt; d =  {'Python': 'Rocks', 'Parrot': 'Dead', 'Favorite Color': 'Blue'}
&gt;&gt;&gt; for key in d:
&gt;&gt;&gt; 	print key, d[key]
						</code></pre></p>
					</section>
					
					<section>
					    <p>Ou ainda:</p>
					    
					    <p><pre><code data-trim>
&gt;&gt;&gt; d =  {'Python': 'Rocks', 'Parrot': 'Dead', 'Favorite Color': 'Blue'}
&gt;&gt;&gt; for (key, value) in d.iteritems():
&gt;&gt;&gt;     print key, value
					    </code></pre></p>
					</section>
                </section>
                
                <section>
                    <section>
                        <h2>Slices</h2>
                    </section>
                    
                    <section>
                        <p>Slice é uma "extensão" de indíces de acesso.</p>
                        
                        <p>Com slices, é possível "cortar" iteráveis, retornando
                        um novo iterável.</p>
                    </section>
                    
                    <section>
                        <p><pre><code data-trim>
iterável[start:end:step]
                        </code></pre></p>
                        
                        <p>(<code>end</code> é exclusívo.)</p>
                    </section>
                    
                    <section>
                        <p><pre><code data-trim>
&gt;&gt;&gt; a = [1, 2, 3, 4]
&gt;&gt;&gt; print a[1:2]
[2]
                        </code></pre></p>
                    </section>
                    
                    <section>
                        <p>Deixar um índice em branco indica que:</p>
                        
                        <ul>
                            <li><code>start</code> = 0</li>
                            <li><code>end</code> = len(iterável)</li>
                            <li><code>step</code> = 1</li>
                        </ul>
                        
                        <p><pre><code data-trim>
&gt;&gt;&gt; a = [1, 2, 3, 4]
&gt;&gt;&gt; print a[:2]
[1, 2]
                        </code></pre></p>
                    </section>
                    
                    <section>
                        <p>Índices negativos começam do final do iterável.</p>
                        
                        <p><pre><code data-trim>
&gt;&gt;&gt; a = [1, 2, 3, 4]
&gt;&gt;&gt; print a[1:-1]
[2, 3]
                        </code></pre></p>
                    </section>
                    
                    <section>
                        <p>Lembre-se que strings também são iteráveis.</p>
                        
                        <p><pre><code data-trim>
&gt;&gt;&gt; a = 'Python Rocks'
&gt;&gt;&gt; print a[7:-1]
'Rock'
                        </code></pre></p>
                    </section>
                    
                    <section>
                        <p>Deixar os dois índices em branco cria uma cópia "flat".</p>
                        <p><pre><code data-trim>
&gt;&gt;&gt; a = [1, 2, 3, 4]
&gt;&gt;&gt; print a[:]
[1, 2, 3, 4]
                        </code></pre></p>
                        
                        <p>Para fazer uma cópia de uma lista com outros
                        iteráveis internos, existe o módulo <code>deepcopy</code>.</p>
                    </section>
                </section>

				<section>
					<section>
						<h2>Funções</h2>
					</section>

					<section>
						<h3><code>def [nome_da_função]([parâmetro], [parâmetro], ...):</code></h3>

						<p><pre><code data-trim>
&gt;&gt;&gt; def funcao(a, b, c):
&gt;&gt;&gt;     return (a + b) / c
						</code></pre></p>
					</section>

					<section>
						<p>Parâmetros podem ser nomeados.</p>

						<p><pre><code data-trim>
&gt;&gt;&gt; def funcao(a, b, c):
&gt;&gt;&gt;     return (a + b) / c
&gt;&gt;&gt;
&gt;&gt;&gt; funcao(b=2, c=3, a=10)
4
						</code></pre></p>
					</section>
				</section>
				
				<section>
				    <section>
				        <h2>Classes</h2>
				    </section>
				    
				    <section>
				        <p>Ok, algumas coisas a serem vistas antes de entrar em
				        classes:</p>
				    </section>
				    
				    <section>
				        <p>Existem dois tipos de classes: old-style e new-style.</p>
				        
				        <p>A diferença é que classes "new-style" sempre extendem da
				        classe <code>object</code>, enquanto que "old-style" não
				        extendem ninguém.</p>
				        
				        <p>Por baixo dos panos, "new-style" e "old-style" funcionam
				        de forma diferente, mas isso não é visível para o
				        programador.</p>
				    </section>
				    
				    <section>
				        <p>Para todos os casos e efeitos, "old-style" não deve
				        mais ser usado.</p>
				        
				        <p class='fragment'>No Python 3, não existem mais
				        classes "old-style", mas a sintaxe removeu a necessidade
				        de extender <code>object</code>.</p>
				        
				        <p class='fragment'>(Ou seja, no Python 3 uma classe
				        se parece com o "old-style" do Python 2.)</p>
				    </section>
				    
				    <section>
				        <p><code>this</code>/<code>self</code> não é uma variável
				        implícita da classe: Ela tem que constar <i>sempre</i>
				        na definiçào do método.</p>
				    </section>
				    
				    <section>
				        <p>O construtor da classe é chamado <code>__init__</code>.</p>
				        
				        <p>Não existe função para o destrutor.</p>
				        
				        <p class='fragment'>Existem ainda outras funções (como o
				        <code>__getitem__</code> comentado anteriormente), mas
				        não vamos falar sobre elas nesse momento.</p>
				    </section>
				    
				    <section>
	    			    <p><pre><code data-trim>
&gt;&gt;&gt; class MyClasse(object):
&gt;&gt;&gt;     def __init__(self):
&gt;&gt;&gt;         self.valor = 0
&gt;&gt;&gt;     def show(self):
&gt;&gt;&gt;         print self.valor
    				    </code></pre></p>
				    </section>
				    
				    <section>
				        <p>Para instanciar uma classe, basta chamar a classe
				        como se fosse uma função.</p>
				        
				        <p><pre><code data-trim>
&gt;&gt;&gt; my = MyClasse()
&gt;&gt;&gt; my.show()
0
				        </code></pre></p>
				    </section>
				    
				    <section>
				        <p>Se o construtor tiver parâmetros, estes devem ser
				        passados durante a instanciação, como se a "função"
				        classe tivesse parâmetros.</p>
				        
				        <p><pre><code data-trim>
&gt;&gt;&gt; class MyClasse(object):
&gt;&gt;&gt;     def __init__(self, name):
&gt;&gt;&gt;         self.name = name        
&gt;&gt;&gt;     def show(self):
&gt;&gt;&gt;         print self.name
        
&gt;&gt;&gt; my = MyClasse('Julio')
&gt;&gt;&gt; my.show()
Julio
				        </code></pre></p>
				    </section>

					<section>
						<p>Herança</p>

				        <p><pre><code data-trim>
&gt;&gt;&gt; class A(object):
&gt;&gt;&gt;     def __init__(self):
&gt;&gt;&gt;         self.value = 10
&gt;&gt;&gt; class B(A):
&gt;&gt;&gt;     def __init__(self):
&gt;&gt;&gt;         super(B, self).__init__()
&gt;&gt;&gt;         self.name = 'AAAA'
				        </code></pre></p>
					</section>

					<section>
						<p>Herança Múltipla</p>

				        <p><pre><code data-trim>
&gt;&gt;&gt; class A(object):
&gt;&gt;&gt;     def __init__(self):
&gt;&gt;&gt;         self.value = 10
&gt;&gt;&gt; class B(object):
&gt;&gt;&gt;     def __init__(self):
&gt;&gt;&gt;         self.name = 'AAAA'
&gt;&gt;&gt; class C(A, B):
&gt;&gt;&gt;     def __init__(self):
&gt;&gt;&gt;         super(C, self).__init__()
				        </code></pre></p>
					</section>

					<section>
						<p>No Python 3, basta usar <code>super().__init__()</code>.
					</section>
				</section>

				<section>
					<h2>As Esquisitices de Python</h2>
				</section>

				<section>
					<section>
						<h3>Strings São Imutáveis</h3>
					</section>

					<section>
				        <p><pre><code data-trim>
&gt;&gt;&gt; a = 'string 1'
&gt;&gt;&gt; b = 'string 2'
&gt;&gt;&gt; c = a + ' ' + b
				        </code></pre></p>

						<ul>
							<li>Cria um objeto que é o conteúdo de "a" com um espaço.</li>
							<li>Cria um novo objeto que é o novo objeto mais o conteúdo de "b".</li>
							<li>Atribui o novo objeto à "c".</li>
						</ul>
					</section>

					<section>
						<p>Forma correta de concatenar strings:</p>

				        <p><pre><code data-trim>
&gt;&gt;&gt; a = 'string 1'
&gt;&gt;&gt; b = 'string 2'
&gt;&gt;&gt; c = ' '.join([a, b])
				        </code></pre></p>
					</section>
				</section>

				<section>
					<section>
						<h3>Listas São Mutáveis</h3>
					</section>

					<section>
				        <p><pre><code data-trim>
&gt;&gt;&gt; def a(l=[]):
&gt;&gt;&gt;     l.append(1)
&gt;&gt;&gt;     print l
&gt;&gt;&gt;
&gt;&gt;&gt; a()
[1]
&gt;&gt;&gt; a()
[1, 1]
				        </code></pre></p>
					</section>

					<section>
						<p>Forma correta de lidar com parâmetros mutáveis:</p>

				        <p><pre><code data-trim>
&gt;&gt;&gt; def a(l=None):
&gt;&gt;&gt;     if not l:
&gt;&gt;&gt;         l = []
&gt;&gt;&gt;     l.append(1)
&gt;&gt;&gt;
&gt;&gt;&gt; a()
[1]
&gt;&gt;&gt; a()
[1]
				        </code></pre></p>
					</section>
				</section>

				<section>
					<section>
						<h3>Stars</h3>
					</section>

					<section>
						<p>"Stars" servem para empacotar e desempacotar parâmetros indefinidos.</p>
					</section>

					<section>
				        <p><pre><code data-trim>
&gt;&gt;&gt; def a(*args):
&gt;&gt;&gt;     print args
&gt;&gt;&gt;
&gt;&gt;&gt; a(1)
[1]
&gt;&gt;&gt; a(1, 2, 3, 4, 5)
[1, 2, 3, 4, 5]
				        </code></pre></p>

						<p><code>*</code> pega somente os parâmetros que não tem nome.</p>
					</section>

					<section>
				        <p><pre><code data-trim>
&gt;&gt;&gt; def a(**kwargs):
&gt;&gt;&gt;     print kwargs
&gt;&gt;&gt;
&gt;&gt;&gt; a(a=1)
{a: 1}
&gt;&gt;&gt; a(value1=10, a=2)
{value1: 10, a: 2}
				        </code></pre></p>

						<p><code>**</code> pega somente os parâmetros que tem nome.</p>
					</section>

					<section>
				        <p><pre><code data-trim>
&gt;&gt;&gt; def a(*args, **kwargs):
&gt;&gt;&gt;     print args
&gt;&gt;&gt;     print kwargs
&gt;&gt;&gt;
&gt;&gt;&gt; a(a=1)
[]
{a: 1}
&gt;&gt;&gt; a(1, 2, 3, a=5)
[1, 2, 3]
{a: 5}
				        </code></pre></p>
					</section>

					<section>
				        <p><pre><code data-trim>
&gt;&gt;&gt; def a(a, b, *args, name=None, **kwargs):
&gt;&gt;&gt;     print 'a =', a
&gt;&gt;&gt;     print 'b =', b
&gt;&gt;&gt;     print 'args =', args
&gt;&gt;&gt;     print 'name = ', name
&gt;&gt;&gt;     print 'kwargs =', kwargs
				        </code></pre></p>
					</section>

					<section>
						<img src='_images/boring.gif'>

						<p>BORING!</p>
					</section>

					<section>
						<p>A parte legal dos stars não é usar para criar funções que aceitam
						qualquer parâmetro (embora isso seja legal em alguns casos).</p>

						<p>A parte legal é fazer chamadas de funções com dicionários.</p>
					</section>

					<section>
				        <p><pre><code data-trim>
&gt;&gt;&gt; def funcao(a, b, c):
&gt;&gt;&gt;     return (a + b) / c
&gt;&gt;&gt;
&gt;&gt;&gt; params = {b: 2, c: 3, a:10}
&gt;&gt;&gt; funcao(**params)
				        </code></pre></p>
					</section>
				</section>

				<section>
					<section>
						<h3>"Functions are First Class Citizens"</h3>
					</section>

					<section>
				        <p><pre><code data-trim>
&gt;&gt;&gt; def funcao(a, b, c):
&gt;&gt;&gt;     return (a + b) / c
&gt;&gt;&gt;
&gt;&gt;&gt; def check(a, b, c, condition, function):
&gt;&gt;&gt;     if condition:
&gt;&gt;&gt;         print function(a, b, c)
&gt;&gt;&gt;
&gt;&gt;&gt; check(1, 2, 3, True, funcao)
1
&gt;&gt;&gt; check(1, 2, 3, False, funcao)
&gt;&gt;&gt;
				        </code></pre></p>
					</section>
				</section>

				<section>
					<section>
						<h3>Decorators</h3>
					</section>

					<section>
					</section>
				</section>
            </div>
        </div>

        <script src="_external/head.min.js"></script>
        <script src="_external/reveal.min.js"></script>

        <script>
            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                theme: 'night',
                transition: 'linear',

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: '_external/classList.js', condition: function() { return !document.body.classList; } },
                    { src: '_external/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '_external/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '_external/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: '_external/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: '_external/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                ]
            });

        </script>

    </body>
</html>
